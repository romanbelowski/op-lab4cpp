# op-lab4cpp
Лабораторна робота 4

## Варіант #0. Архіви

Завдання полягає в розробці простого архіватора. На вхід програми через параметри командного рядка подається ім'я вхідного та вихідного файлів та параметр, який вказує, що треба зробити – спакувати чи розпакувати вхідний файл. Алгоритм можете вибрати довільний, кілька алгоритмів є у посиланнях нижче. Наприклад, ви можете замінювати байти, що повторюються, на коротше представлення (run length encoding).

*Складніше завдання (+1 бал):* Створювати архів з кількох файлів та/або використати алгоритм стиснення Lempel—Ziv. Підійде будь-яка з версій алгоритму на ваш вибір. Найпростіша, на мою думку, LZW. 

Майте на увазі: LZ дуже простий алгоритм, складність у тому, що в цьому завданні ви матимете справу з великою кількість побітових операцій для роботи з числами, які мають 9, 10, 11 біт тощо, а не звичайними 8-, 16- і 32-бітними, до яких звикли. Вам може стати в нагоді ця книга: [Hacker's Delight](https://www.amazon.com/Hackers-Delight-2nd-Henry-Warren/dp/0321842685) (переклад: [Алгоритмические трюки для програмистов](https://www.google.com/search?q=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5+%D1%82%D1%80%D1%8E%D0%BA%D0%B8+%D0%B4%D0%BB%D1%8F+%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%B8%D1%81%D1%82%D0%BE%D0%B2)). 

Будь ласка, не намагайтеся писати архіватор, що записує символи (char) '1' та '0' у файл, це неправильний варіант виконання роботи. Пам'ятайте, мінімальна кількість бітів, яку ви можете записати за один раз у файл – 8, або 1 байт. Тому вам потрібно спочатку перетворити 8 біт в один байт – і лише потім записати у файл. 

Використовуйте побітові операції (>>, <<, &, |)  щоб зчитувати і записувати окремі біти в байті. Наприклад, щоб прочитати останній біт в байті ви можете виконати

```c++
byte a; // ви хочете зчитати останній (найменш вагомий) біт в цьому числі
int result = a & 1; // тепер result містить 1, якщо останній біт в a 1, і 0, якщо - 0
//      a:  ...1 1 0 1 0 1             a:  ...1 1 0 1 0 0
//      1:  ...0 0 0 0 0 1   або       1:  ...0 0 0 0 0 1
// result:  ...0 0 0 0 0 1        result:  ...0 0 0 0 0 0
```

Щоб записати 1 в останній біт:
```c++
byte a; // ви хочете записати 1 в останній (найменш вагомий) біт в цьому числі
byte result = (byte) (a | 1);

//      a:  ...1 1 0 1 0 0             a:  ...1 1 0 1 0 1
//      1:  ...0 0 0 0 0 1   або       1:  ...0 0 0 0 0 1
// result:  ...1 1 0 1 0 1        result:  ...1 1 0 1 0 1
```

Щоб записати 0 в останній біт (скинути його), але не змінювати всі інші:
```c++
byte a; // ви хочете записати 1 в останній (найменш вагомий) біт в цьому числі
byte result = (byte) (a & 0xFE); // або a & (~1) за допомогою побітового NOT

//      a:  ...1 1 0 1 0 1             a:  ...1 1 0 1 0 0
//     ~1:  ...1 1 1 1 1 0   або      ~1:  ...1 1 1 1 1 0
// result:  ...1 1 0 1 0 0        result:  ...1 1 0 1 0 0
```

Зчитати 3-й біт:
```c++
byte a; // ви хочете зчитати 3-й біт в цьому числі
int result = a & (1 << 2); // тепер result містить 0, якщо останній біт в a 0, і не 0, якщо - 1
//      a:  ...1 1 0 1 0 1             a:  ...1 1 0 0 0 1
// 1 << 2:  ...0 0 0 1 0 0   або  1 << 3:  ...0 0 0 1 0 0
// result:  ...0 0 0 1 0 0        result:  ...0 0 0 0 0 0
```

Записати 11 біт у 2 байти так, щоб у першому байті було 6 молодших бітів, а в другому 5 старших:
```c++
// тут є 11 біт, які нас цікавлять. Наприклад: 10111010110 (десяткове 1494)
int number;

// візьмемо 6 молодших бітів з цього числа, для цього виконаємо побітове І з байтом 00111111 (зазвичай називається маскою):
// ...10111010110 &
// ...00000111111 =
// ...00000010110
byte low = (byte) (number & 0x3F);
// маску 0x3F для 6 бітів ми можемо отримати як (1 << 6) - 1

// візьмемо 5 старших бітів з числа, для цього можемо спочаку посунути біти праворуч на 6, а потім виконати ту саму операцію, що й вище.
// ...10111010110 >> 6 =
// ...00000010111 &
// ...00000011111 =
// ...00000010111
byte high = (byte)((number >> 6) & 0x1F);
// маску 0x1F для 5 бітів ми можемо отримати як (1 << 5) - 1

// для прикладу, можемо уявити, що хочему записати біти з числа low у інший байт result, в якому 2 старших біти вже зайняті іншими даними, а молодші - всі 0. Тоді ми виконати побітове АБО:
// 10_000000 &
// 00_010110 =
// 10_010110

result = (byte)(result | low);
// тепер байт result містить по одній частині двох чисел (наприклад, 11-бітних)
```

### Вхідні та вихідні дані
Для стискування на вхід подається один або кілька файлів у довільному форматі (ви не знаєте наперед, які файли стискатиме користувач), на виході отримуємо архів. Наприклад, якщо ваша програма компілюється в megazip.exe:
```
> megazip.exe --compress output.mgzip input.bmp
Compressing file input.bmp... Done.
Result written to output.mgzip

// Або якщо підтримується кілька файлів
> megazip.exe --compress output.mgzip input1.bmp input2.bmp input3.bmp
Compressing file input1.bmp... Done.
Compressing file input2.bmp... Done.
Compressing file input3.bmp... Done.
Result written to output.mgzip
```

Для розпаковування на вхід подається ім\'я вхідного файла. Ім\'я вихідних файлів зазвичай збережене всередині архіву.
```
> megazip.exe --decompress output.mgzip
Getting out file input1.bmp... Done.
Getting out file input2.bmp... Done.
Getting out file input3.bmp... Done.
3 files written.
```

### Посилання
* [Стиснення файлів](https://en.wikipedia.org/wiki/Lossless_compression)
* [Run length encoding](https://en.wikipedia.org/wiki/Run-length_encoding)
* [Lempel—Ziv](http://math.mit.edu/~goemans/18310S15/lempel-ziv-notes.pdf) (1 частина документа). Підійде будь-яка з версій алгоритму на ваш вибір. 